// @flow
import jwkToPem from 'jwk-to-pem';
import jwt from 'jsonwebtoken';
import Promise from 'bluebird';
import rp from 'request-promise';
import OAuth2 from 'simple-oauth2';
import config from '@fpm/config';
import log from '@fpm/logging';

const jwtVerify = (token, secret, options) =>
  new Promise((resolve, reject) =>
    jwt.verify(token, secret, options || {}, (error, decoded) => (error && reject(error)) || resolve(decoded))
  );

const jwtSign = (data, key) =>
  new Promise((resolve, reject) =>
    jwt.sign(
      data,
      jwkToPem(
        Object.assign({}, key, {
          // the following keys are optional in the spec but for some reason required by the library.
          dp: '',
          dq: '',
          qi: ''
        }),
        { private: true }
      ),
      { algorithm: 'RS256' },
      (error, token) => (error && reject(error)) || resolve(token)
    )
  );

class Hydra {
  cache: ?Object;
  url: string;
  scope: string;
  clientId: string;
  clientSecret: string;
  cacheKeyAccessTokenMgmt: string;
  oauth2Config: Object;

  constructor({ cache, scope, clientId, clientSecret }: Object = {}) {
    this.cache = cache;
    this.url = config.get('hydra:url');
    this.clientId = clientId || config.get('hydra:clientId');
    this.clientSecret = clientSecret || config.get('hydra:clientSecret');
    this.scope = scope || config.get('hydra:scope');
    this.cacheKeyAccessTokenMgmt = `hydra:mgmt:at:${this.clientId}`;
    this.oauth2Config = {
      client: {
        id: this.clientId,
        secret: this.clientSecret
      },
      auth: {
        tokenHost: this.url,
        authorizePath: '/oauth2/auth',
        tokenPath: '/oauth2/token'
      }
    };
  }

  async getConsentRequest({ consent, client_id, clientId, client_secret, clientSecret }) {
    let tm = new Date();
    const reply = await this.basicReq({
      method: 'GET',
      path: `/oauth2/consent/requests/${consent}`,
      client_id,
      clientId,
      client_secret,
      clientSecret
    });
    tm = new Date() - tm;
    log.debug(`Hydra:getConsentRequest ${tm}ms`);
    return reply;
  }

  // {
  //   "admin": {
  //     "id": "admin",
  //     "client_name": "This temporary client is generated by hydra and is granted all of hydra's administrative privileges. It must be removed when everything is set up.",
  //     "redirect_uris": [
  //       "http://localhost:4445/callback"
  //     ],
  //     "grant_types": [
  //       "implicit",
  //       "refresh_token",
  //       "authorization_code",
  //       "password",
  //       "client_credentials"
  //     ],
  //     "response_types": [
  //       "id_token",
  //       "code",
  //       "token"
  //     ],
  //     "scope": "hydra openid offline",
  //     "owner": "",
  //     "policy_uri": "",
  //     "tos_uri": "",
  //     "client_uri": "",
  //     "logo_uri": "",
  //     "contacts": null,
  //     "public": false
  //   }
  // }
  async listClients() {
    let tm = new Date();
    const reply = await this.bearerReq({ path: '/clients' });
    tm = new Date() - tm;
    log.debug(`Hydra:listClients ${tm}ms`);
    return reply;
  }

  async createClient(body: Object) {
    let tm = new Date();
    const reply = await this.bearerReq({
      method: 'POST',
      path: '/clients',
      body
    });
    tm = new Date() - tm;
    log.debug(`Hydra:createClient ${tm}ms`);
    return reply;
  }

  async fetchClient(id: string) {
    let tm = new Date();
    const reply = await this.bearerReq({ path: `/clients/${id}` });
    tm = new Date() - tm;
    log.debug(`Hydra:fetchClient ${tm}ms`);
    return reply;
  }

  async updateClient(id: string, body: Object) {
    let tm = new Date();
    const reply = await this.bearerReq({
      method: 'PUT',
      path: `/clients/${id}`,
      body
    });
    tm = new Date() - tm;
    log.debug(`Hydra:updateClient ${tm}ms`);
    return reply;
  }

  async deleteClient(id: string) {
    let tm = new Date();
    const reply = await this.bearerReq({
      method: 'DELETE',
      path: `/clients/${id}`
    });
    tm = new Date() - tm;
    log.debug(`Hydra:deleteClient ${tm}ms`);
    return reply;
  }

  async fetchKey(keySet: string, kind: string, useCache: ?Boolean) {
    let tm = new Date();
    let key;
    const cacheKey = `${this.cacheKeyAccessTokenMgmt}:key:${keySet}:${kind}`;
    if (useCache) {
      key = await this.cache.get(cacheKey);
      if (key) {
        return JSON.parse(key);
      }
    }
    const reply = await this.bearerReq({ path: `/keys/${keySet}/${kind}` });
    key = reply && reply.keys && reply.keys.length && reply.keys[0];
    if (key && useCache) {
      await this.cache.set(cacheKey, JSON.stringify(key), 1 * 60 * 60);
    }
    tm = new Date() - tm;
    log.debug(`Hydra:fetchKey ${tm}ms`);
    return key;
  }

  async verifyConsentChallenge(challenge: string, useCache: ?Boolean) {
    const key = await this.fetchKey('hydra.consent.challenge', 'public', useCache);
    return await jwtVerify(challenge, jwkToPem(key));
  }

  async generateConsentResponse(decodedChallenge: Object, subject, scopes, at = {}, idt = {}, useCache: ?Boolean) {
    const key = await this.fetchKey('hydra.consent.response', 'private', useCache);
    const { aud, exp, jti } = decodedChallenge;
    return await jwtSign({ jti, aud, exp, scp: scopes, sub: subject, at_ext: at, id_ext: idt }, key);
  }

  async authorizationCodeToAccessToken({ code, redirect_uri, client_id, client_secret }) {
    let tm = new Date();
    const reply = await this.basicReq({
      method: 'POST',
      path: '/oauth2/token',
      form: {
        code,
        redirect_uri,
        grant_type: 'authorization_code'
      },
      client_id,
      client_secret
    });
    tm = new Date() - tm;
    log.debug(`Hydra:authorizationCodeToAccessToken ${tm}ms`);
    return reply;
  }

  async createAccessToken({ refresh_token, client_id, client_secret }) {
    let tm = new Date();
    const reply = await this.basicReq({
      method: 'POST',
      path: '/oauth2/token',
      form: {
        refresh_token,
        grant_type: 'refresh_token'
      },
      client_id,
      client_secret
    });
    tm = new Date() - tm;
    log.debug(`Hydra:createAccessToken ${tm}ms`);
    return reply;
  }

  async introspectToken(token: String) {
    let tm = new Date();
    const reply = await this.bearerReq({
      method: 'POST',
      path: '/oauth2/introspect',
      form: { token }
    });
    tm = new Date() - tm;
    log.debug(`Hydra:introspectToken ${tm}ms`);
    return reply;
  }

  async revokeToken({ access_token, refresh_token }) {
    let tm = new Date();
    const reply = await this.bearerReq({
      method: 'POST',
      path: '/oauth2/revoke',
      form: access_token ? { access_token } : refresh_token ? { refresh_token } : {}
    });
    tm = new Date() - tm;
    log.debug(`Hydra:revokeToken ${tm}ms`);
    return reply;
  }

  async revokeRefreshToken({ refresh_token, client_id, client_secret }) {
    let tm = new Date();
    const reply = await this.basicReq({
      method: 'POST',
      path: '/oauth2/revoke',
      form: { refresh_token },
      client_id,
      client_secret
    });
    tm = new Date() - tm;
    log.debug(`Hydra:revokeRefreshToken ${tm}ms`);
    return reply;
  }

  async getAccessTokenMgmt() {
    let accessToken;
    if (this.cache) {
      accessToken = await this.cache.get(this.cacheKeyAccessTokenMgmt);
    }
    if (!accessToken) {
      const token = await this.createAccessTokenMgmt();
      accessToken = token && token.access_token;
      if (token && this.cache) {
        await this.cache.set(this.cacheKeyAccessTokenMgmt, accessToken, token.expires_in || 1 * 60 * 60);
      }
    }
    return accessToken;
  }

  async createAccessTokenMgmt() {
    let tm = new Date();
    const tkn = await new Promise((resolve, reject) => {
      const oauth2 = OAuth2.create(this.oauth2Config);
      oauth2.clientCredentials.getToken({ scope: this.scope }, (error, result) => {
        if (error) {
          return reject({ message: `Could not retrieve access token: ${error.message}` });
        }
        const { token } = oauth2.accessToken.create(result) || {};
        return resolve(token);
      });
    });
    tm = new Date() - tm;
    log.debug(`Hydra:createAccessTokenMgmt ${tm}ms`);
    return tkn;
  }

  extractError(e: ?Object) {
    const response = e && e.response && e.response.toJSON && e.response.toJSON();
    const body = response && response.body;
    const { error, error_description } = body || {};
    return { response, body, error, error_description, statusCode: e.statusCode };
  }

  async bearerReq(args) {
    const bearer = await this.getAccessTokenMgmt();
    return this.req({ ...args, auth: { bearer } });
  }

  async basicReq({ client_id, clientId, client_secret, clientSecret, headers, ...args }) {
    const Authorization = `Basic ${new Buffer(`${client_id || clientId}:${client_secret || clientSecret}`).toString(
      'base64'
    )}`;
    return this.req({
      ...args,
      headers: Object.assign({}, headers || {}, { Authorization })
    });
  }

  async authReq(args) {
    return this.req({
      ...args,
      auth: {
        user: this.clientId,
        pass: this.clientSecret
      }
    });
  }

  async req({ path, ...overrides }) {
    try {
      return rp(
        Object.assign(
          {
            json: true,
            url: `${this.url}${path || ''}`
          },
          overrides
        )
      );
    } catch (e) {
      throw extractError(e);
    }
  }
}

export default Hydra;
